<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StreakMaster Pro - Fixed Stakes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .connection-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }

        .input-group label {
            min-width: 120px;
            font-weight: bold;
        }

        .input-group input, .input-group select {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 14px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        .btn-danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(244, 67, 54, 0.4);
        }

        .btn-warning {
            background: linear-gradient(45deg, #ff9800, #f57c00);
            color: white;
        }

        .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 152, 0, 0.4);
        }

        .status-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .status-card {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .status-card:hover {
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-3px);
        }

        .status-card h3 {
            font-size: 0.8em;
            margin-bottom: 8px;
            color: #ccc;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .status-card .value {
            font-size: 1.8em;
            font-weight: bold;
            color: #fff;
        }

        .last-digit {
            font-size: 3em !important;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .pairs-panel {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .pairs-panel h3 {
            margin-bottom: 15px;
            color: #4ecdc4;
            text-align: center;
        }

        .pairs-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .pair-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid transparent;
        }

        .pair-card.active {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
        }

        .pair-card.ready-to-trade {
            border-color: #ff9800;
            background: rgba(255, 152, 0, 0.2);
            animation: readyPulse 2s infinite;
        }

        @keyframes readyPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .pair-header {
            font-weight: bold;
            margin-bottom: 10px;
            color: #4ecdc4;
        }

        .pair-status {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .trading-controls {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
        }

        .control-group h4 {
            margin-bottom: 10px;
            color: #4ecdc4;
        }

        .risk-tabs {
            display: flex;
            margin-bottom: 15px;
        }

        .risk-tab {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .risk-tab.active {
            background: linear-gradient(45deg, #4CAF50, #45a049);
        }

        .risk-tab:first-child {
            border-radius: 5px 0 0 5px;
        }

        .risk-tab:last-child {
            border-radius: 0 5px 5px 0;
        }

        .log-section {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            max-height: 300px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-success { color: #4CAF50; }
        .log-error { color: #f44336; }
        .log-warning { color: #ff9800; }
        .log-info { color: #2196F3; }

        .connection-status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .connected {
            background: #4CAF50;
            color: white;
        }

        .disconnected {
            background: #f44336;
            color: white;
        }

        .connecting {
            background: #ff9800;
            color: white;
        }

        .stake-input {
            width: 80px;
            padding: 5px;
            margin: 2px;
            border: none;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 0.8em;
        }

        .emergency-stop {
            background: linear-gradient(45deg, #ff1744, #d50000);
            color: white;
            font-size: 16px;
            padding: 15px 30px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            margin: 10px 0;
            animation: pulse 2s infinite;
            width: 100%;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 23, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 23, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 23, 68, 0); }
        }

        .risk-indicator {
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            text-align: center;
            font-weight: bold;
        }

        .risk-low { background: rgba(76, 175, 80, 0.3); }
        .risk-medium { background: rgba(255, 152, 0, 0.3); }
        .risk-high { background: rgba(244, 67, 54, 0.3); }

        /* Loss Threshold Panel */
        .loss-threshold-panel {
            background: rgba(255, 152, 0, 0.1);
            border: 2px solid rgba(255, 152, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .threshold-status {
            background: rgba(255, 152, 0, 0.2);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-weight: bold;
            text-align: center;
        }

        .threshold-reached {
            background: rgba(76, 175, 80, 0.3);
            color: #4CAF50;
        }

        .threshold-waiting {
            background: rgba(244, 67, 54, 0.3);
            color: #f44336;
        }

        /* FIXED Stakes Display */
        .stakes-explanation {
            background: rgba(76, 175, 80, 0.2);
            border: 2px solid rgba(76, 175, 80, 0.4);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .controls-grid, .pairs-grid {
                grid-template-columns: 1fr;
            }
            
            .input-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .input-group label {
                min-width: auto;
                margin-bottom: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>StreakMaster Pro - FIXED STAKES</h1>
            <p>✅ Always Start at Base Stakes | ✅ Progressive Only on Losses | ✅ Counter Controls Trading Permission</p>
        </div>

        <div class="connection-section">
            <div class="input-group">
                <label>API Token:</label>
                <input type="password" id="apiToken" placeholder="Enter your Deriv API token">
                <button class="btn btn-primary" onclick="connectWebSocket()">Connect</button>
                <button class="btn btn-danger" onclick="disconnectWebSocket()">Disconnect</button>
            </div>
            <div class="input-group">
                <label>Status:</label>
                <span id="connectionStatus" class="connection-status disconnected">Disconnected</span>
            </div>
        </div>

        <!-- Loss Threshold Panel -->
        <div class="loss-threshold-panel">
            <h3 style="color: #ff9800; margin-bottom: 15px;">🎯 Loss Threshold Control</h3>
            <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                <label style="font-weight: bold; min-width: 150px;">Loss Threshold (0-10):</label>
                <input type="number" id="lossThresholdValue" value="2" min="0" max="10" step="1" 
                       style="padding: 8px; border-radius: 5px; border: none; width: 80px;" 
                       onchange="updateLossThreshold(this.value)">
                <span style="font-size: 0.9em; color: #ccc;">Pairs need counter ≥ this value to trade</span>
            </div>
            <div class="threshold-status threshold-waiting" id="thresholdStatus">
                🚫 No pairs ready - All counters below threshold (2)
            </div>
        </div>

        <div class="status-panel">
            <div class="status-card">
                <h3>Last Digit</h3>
                <div class="value last-digit" id="lastDigit">-</div>
            </div>
            <div class="status-card">
                <h3>Current Streak</h3>
                <div class="value" id="currentStreak">0</div>
            </div>
            <div class="status-card">
                <h3>Max Streak</h3>
                <div class="value" id="maxStreak">0</div>
            </div>
            <div class="status-card">
                <h3>Balance</h3>
                <div class="value" id="balance">$0.00</div>
            </div>
            <div class="status-card">
                <h3>P&L</h3>
                <div class="value" id="totalPnL">$0.00</div>
            </div>
        </div>

        <div class="pairs-panel">
            <h3>Pair Status Monitor</h3>
            <div class="pairs-grid" id="pairsGrid"></div>
        </div>

        <div class="trading-controls">
            <div class="controls-grid">
                <div class="control-group">
                    <h4>Trading Settings</h4>
                    <div class="input-group">
                        <label>Auto Trading:</label>
                        <button class="btn btn-primary" id="autoTradingBtn" onclick="toggleAutoTrading()">Start Auto Trading</button>
                    </div>
                    <button class="emergency-stop" onclick="emergencyStop()">🛑 EMERGENCY STOP</button>
                    <div class="input-group">
                        <button class="btn btn-warning" onclick="resetAllPairs()">Reset All Pairs</button>
                    </div>
                </div>

                <div class="control-group">
                    <h4>Risk Level & Stakes</h4>
                    <div class="risk-tabs">
                        <button class="risk-tab active" onclick="setRiskLevel('low')">Low Risk</button>
                        <button class="risk-tab" onclick="setRiskLevel('medium')">Medium Risk</button>
                        <button class="risk-tab" onclick="setRiskLevel('high')">High Risk</button>
                    </div>
                    <div id="stakeSettings"></div>
                    <div id="riskIndicator" class="risk-indicator risk-low">
                        Current Risk: LOW - Always Start at Base Stakes
                    </div>
                    <div class="stakes-explanation">
                        <strong>✅ FIXED LOGIC:</strong><br>
                        • Counter determines IF pair can trade (≥ threshold)<br>
                        • All pairs ALWAYS start at base stakes: (0.35, 0.50)<br>
                        • Stakes progress only after losses within same session<br>
                        • Win = Reset stakes back to (0.35, 0.50)
                    </div>
                </div>
            </div>
        </div>

        <div class="log-section">
            <h3>Trading Log</h3>
            <div id="tradingLog"></div>
        </div>
    </div>

    <script>
        // FIXED: Enhanced Trading Bot with Correct Stakes Logic
        class StreakMasterProFixed {
            constructor() {
                this.ws = null;
                this.connected = false;
                this.currentStreak = 0;
                this.maxStreak = 0;
                this.autoTrading = false;
                this.balance = 0;
                this.sessionStartBalance = 0;
                this.activeTrades = 0;
                this.totalPnL = 0;
                this.requestId = 1;
                this.pendingTrade = null;
                this.riskLevel = 'low';
                
                // FIXED: Base stakes for each risk level
                this.baseStakes = {
                    low: [0.35, 0.50],
                    medium: [5, 6],
                    high: [1, 2]
                };
                
                // Loss Threshold Settings
                this.lossThreshold = 2;
                
                // Risk management
                this.maxDailyLoss = 50;
                this.maxConcurrentTrades = 3;
                this.lastTradeTime = 0;
                this.tradeThrottleMs = 3000;
                this.contractSubscriptions = new Set();
                
                // Extended pairs (5 pairs total)
                this.pairs = [
                    { name: '1st&2nd', streakRange: [1, 2], counter: 0, maxReached: 0, currentStakeLevel: 1 },
                    { name: '3rd&4th', streakRange: [3, 4], counter: 0, maxReached: 0, currentStakeLevel: 1 },
                    { name: '5th&6th', streakRange: [5, 6], counter: 0, maxReached: 0, currentStakeLevel: 1 },
                    { name: '7th&8th', streakRange: [7, 8], counter: 0, maxReached: 0, currentStakeLevel: 1 },
                    { name: '9th&10th', streakRange: [9, 10], counter: 0, maxReached: 0, currentStakeLevel: 1 }
                ];
                
                // FIXED: Stake progression tables (same as before)
                this.stakeTable = {
                    low: [
                        [0.35, 0.50], [1, 2], [3, 6], [12, 21], [35, 61], 
                        [103, 175], [298, 507], [862, 1466], [2494, 4240], [7210, 12264]
                    ],
                    medium: [
                        [5, 6], [12, 22], [39, 66], [116, 197], [339, 576], 
                        [980, 1666], [2837, 4826], [8207, 13958]
                    ],
                    high: [
                        [1, 2], [3, 6], [12, 24], [48, 96], [192, 325], [560, 953], [1628, 2768]
                    ]
                };
                
                this.initializePairsDisplay();
                this.initializeStakeSettings();
                this.updateDisplay();
                this.updateThresholdStatus();
                
                this.tradedOnCurrentStreak = new Set();
                
                // Track active trades by pair to properly handle win/loss
                this.activePairTrades = new Map();
            }

            initializePairsDisplay() {
                const container = document.getElementById('pairsGrid');
                container.innerHTML = '';
                // Show all 5 pairs
                this.pairs.forEach((pair, index) => {
                    const pairCard = document.createElement('div');
                    pairCard.className = 'pair-card';
                    pairCard.id = `pair-${index}`;
                    pairCard.innerHTML = `
                        <div class="pair-header">Pair ${index + 1}: ${pair.name}</div>
                        <div class="pair-status">
                            <span>Counter:</span>
                            <span id="pair-${index}-counter">${pair.counter}</span>
                        </div>
                        <div class="pair-status">
                            <span><strong>Max:</strong></span>
                            <span id="pair-${index}-max" style="color: #ff9800; font-weight: bold;">${pair.maxReached}</span>
                        </div>
                        <div class="pair-status">
                            <span>Range:</span>
                            <span>${pair.streakRange[0]}-${pair.streakRange[1]}</span>
                        </div>
                        <div class="pair-status">
                            <span>Stake Level:</span>
                            <span id="pair-${index}-level" style="color: #4ecdc4;">${pair.currentStakeLevel}</span>
                        </div>
                        <div class="pair-status">
                            <span>Next Stakes:</span>
                            <span id="pair-${index}-stakes" style="color: #4ecdc4;">-</span>
                        </div>
                    `;
                    container.appendChild(pairCard);
                });
            }

            // FIXED: Get stakes based on pair's current stake level, not counter
            getStakesForPair(pairIndex) {
                const pair = this.pairs[pairIndex];
                
                // If counter is 0 or below threshold, no trading
                if (pair.counter < this.lossThreshold) {
                    return [0, 0];
                }
                
                // Get stake table for current risk level
                const stakeTable = this.stakeTable[this.riskLevel];
                
                // Use the pair's current stake level (starts at 1, progresses on losses)
                const stakeIndex = pair.currentStakeLevel - 1;
                
                // Check if stake level exists for this risk level
                if (stakeIndex >= 0 && stakeIndex < stakeTable.length) {
                    return stakeTable[stakeIndex];
                } else {
                    // If level exceeds available stakes, use the last available level
                    this.log(`⚠️ Stake level ${pair.currentStakeLevel} exceeds available levels for ${this.riskLevel} risk. Using max level.`, 'warning');
                    return stakeTable[stakeTable.length - 1];
                }
            }

            initializeStakeSettings() {
                const container = document.getElementById('stakeSettings');
                const baseStakes = this.baseStakes[this.riskLevel];
                
                let html = `<div style="margin-top: 10px;">
                    <strong>Stakes Logic (${this.riskLevel.toUpperCase()} Risk):</strong><br>
                    <div style="font-size: 0.85em; color: #4ecdc4; margin: 5px 0;">
                        All pairs start at: ${baseStakes[0]} (1st) | ${baseStakes[1]} (2nd)
                    </div>`;
                
                this.pairs.forEach((pair, index) => {
                    const stakes = this.getStakesForPair(index);
                    const counterValue = pair.counter;
                    const stakeLevel = pair.currentStakeLevel;
                    
                    html += `<div style="margin: 5px 0; padding: 5px; background: rgba(255,255,255,0.1); border-radius: 3px;">
                        <strong>Pair ${index + 1}</strong> (Counter: ${counterValue}, Level: ${stakeLevel}): `;
                    
                    if (counterValue < this.lossThreshold) {
                        html += `<span style="color: #ccc;">Not ready to trade</span>`;
                    } else {
                        html += `1st: ${stakes[0]} | 2nd: ${stakes[1]}`;
                    }
                    
                    html += `</div>`;
                });
                
                html += `<div style="font-size: 0.8em; color: #4CAF50; margin-top: 10px;">
                    ✅ FIXED: Stakes always start at base level regardless of counter<br>
                    📈 Stakes progress only on losses, reset to base on wins
                </div></div>`;
                
                container.innerHTML = html;
            }

            // FIXED: Updated threshold status logic
            updateThresholdStatus() {
                const statusDiv = document.getElementById('thresholdStatus');
                const readyPairs = this.pairs.filter(pair => pair.counter >= this.lossThreshold);
                
                if (readyPairs.length > 0) {
                    statusDiv.className = 'threshold-status threshold-reached';
                    statusDiv.textContent = `✅ ${readyPairs.length} pairs ready to trade (counter ≥ ${this.lossThreshold})`;
                } else {
                    statusDiv.className = 'threshold-status threshold-waiting';
                    statusDiv.textContent = `🚫 No pairs ready - All counters below threshold (${this.lossThreshold})`;
                }
            }

            connect(apiToken) {
                if (this.connected) {
                    this.log('Already connected', 'warning');
                    return;
                }

                this.updateConnectionStatus('connecting');
                this.log('Connecting to Deriv WebSocket (Demo)...', 'info');

                this.ws = new WebSocket('wss://ws.binaryws.com/websockets/v3?app_id=1089');
                
                this.ws.onopen = () => {
                    this.connected = true;
                    this.updateConnectionStatus('connected');
                    this.log('Connected to Deriv WebSocket (Demo)', 'success');
                    this.authorize(apiToken);
                };

                this.ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        this.handleMessage(data);
                    } catch (error) {
                        this.log(`Error parsing message: ${error}`, 'error');
                    }
                };

                this.ws.onclose = () => {
                    this.connected = false;
                    this.updateConnectionStatus('disconnected');
                    this.log('Disconnected from Deriv WebSocket', 'error');
                    this.autoTrading = false;
                    this.updateAutoTradingButton();
                };

                this.ws.onerror = (error) => {
                    this.log(`WebSocket error: ${error}`, 'error');
                };
            }

            disconnect() {
                if (this.ws) {
                    this.ws.close();
                    this.autoTrading = false;
                    this.updateAutoTradingButton();
                    this.pendingTrade = null;
                    this.contractSubscriptions.clear();
                    this.activePairTrades.clear();
                }
            }

            authorize(token) {
                const message = {
                    authorize: token,
                    req_id: this.requestId++
                };
                this.send(message);
            }

            subscribeToTicks() {
                const message = {
                    ticks: 'R_50',
                    subscribe: 1,
                    req_id: this.requestId++
                };
                this.send(message);
                this.log('Subscribed to Volatility 50 Index ticks', 'info');
                
                setInterval(() => {
                    if (this.connected) {
                        this.getAccountInfo();
                    }
                }, 30000);
            }

            getAccountInfo() {
                const message = {
                    balance: 1,
                    req_id: this.requestId++
                };
                this.send(message);
            }

            send(message) {
                if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                    this.log('Cannot send message - WebSocket not connected', 'error');
                    return;
                }

                try {
                    const msgStr = JSON.stringify(message);
                    this.log('Outgoing: ' + msgStr, 'info');
                    this.ws.send(msgStr);
                } catch (error) {
                    this.log(`Error sending message: ${error}`, 'error');
                }
            }

            handleMessage(data) {
                if (data.error) {
                    this.handleError(data.error);
                    return;
                }

                if (data.authorize) {
                    this.handleAuthorization(data.authorize);
                }

                if (data.tick) {
                    this.handleTick(data.tick);
                }

                if (data.balance) {
                    this.handleBalanceUpdate(data.balance);
                }

                if (data.buy) {
                    this.handleTradeResult(data.buy);
                }

                if (data.proposal) {
                    this.handleProposal(data.proposal, data.req_id);
                }

                if (data.proposal_open_contract) {
                    this.handleContractUpdate(data.proposal_open_contract);
                }
            }

            handleError(error) {
                const errorMsg = error.code ? `${error.code}: ${error.message}` : error.message;
                this.log(`Error: ${errorMsg}`, 'error');
                
                if (this.pendingTrade) {
                    this.log('Clearing pending trade due to error', 'warning');
                    this.pendingTrade = null;
                }
            }

            handleAuthorization(authData) {
                this.log('Authorization successful', 'success');
                this.subscribeToTicks();
                this.getAccountInfo();
            }

            handleBalanceUpdate(balanceData) {
                if (this.sessionStartBalance === 0) {
                    this.sessionStartBalance = balanceData.balance;
                    this.log(`Session started with balance: ${this.sessionStartBalance.toFixed(2)}`, 'info');
                }
                this.balance = balanceData.balance;
                this.updateDisplay();
            }

            handleProposal(proposal, reqId) {
                if (this.pendingTrade && reqId === this.pendingTrade.proposalReqId) {
                    const tradeParams = {
                        buy: proposal.id,
                        price: proposal.ask_price,
                        req_id: this.requestId++,
                        passthrough: {
                            pairIndex: this.pendingTrade.pairIndex,
                            tradeIndex: this.pendingTrade.tradeIndex,
                            streak: this.currentStreak,
                            timestamp: this.pendingTrade.timestamp
                        }
                    };
                    
                    this.log(`Executing trade: Pair ${this.pendingTrade.pairIndex + 1}, Stake ${this.pendingTrade.roundedStake}, Price ${proposal.ask_price}`, 'info');
                    this.send(tradeParams);
                }
            }

            handleTick(tick) {
                const quote = tick.quote;
                const lastDigit = Math.floor(quote * 10000) % 10;
                
                document.getElementById('lastDigit').textContent = lastDigit;
                
                if (lastDigit >= 0 && lastDigit <= 3) {
                    if (this.currentStreak > 0) {
                        this.log(`Streak reset from ${this.currentStreak} to 0`, 'success');
                        this.processStreakReset();
                    }
                    this.currentStreak = 0;
                    this.tradedOnCurrentStreak.clear();
                } else if (lastDigit >= 4) {
                    this.currentStreak++;
                    
                    if (this.currentStreak > this.maxStreak) {
                        this.maxStreak = this.currentStreak;
                    }
                }
                
                this.updateDisplay();
                this.updatePairsDisplay();
                this.updateThresholdStatus();
                this.log(`Tick: ${quote}, Last Digit: ${lastDigit}, Streak: ${this.currentStreak}`, 'info');
                
                // Check trading opportunities if auto trading is enabled
                if (this.autoTrading) {
                    this.checkTradingOpportunities();
                }
            }

            processStreakReset() {
                const lastStreak = this.currentStreak;
                
                // Process all pairs for streak reset logic
                this.pairs.forEach((pair, index) => {
                    const [min, max] = pair.streakRange;
                    if (lastStreak === min || lastStreak === max) {
                        // WIN: streak ended at pair's min or max - reset counter to 0 AND stake level to 1
                        pair.counter = 0;
                        pair.currentStakeLevel = 1; // FIXED: Reset stake level to 1
                        this.log(`✅ Pair ${index + 1} (${pair.name}) WON! Counter reset to 0, Stakes reset to base level`, 'success');
                    } else if (lastStreak > max) {
                        // LOSS: streak ended above the pair's max - increment counter
                        const oldCounter = pair.counter;
                        pair.counter++;
                        
                        // FIXED: Update individual pair's max when counter increases
                        if (pair.counter > pair.maxReached) {
                            pair.maxReached = pair.counter;
                            this.log(`📈 Pair ${index + 1} (${pair.name}) - New Counter Max: ${pair.counter}`, 'info');
                        }
                        
                        this.log(`❌ Pair ${index + 1} (${pair.name}) counter incremented from ${oldCounter} to ${pair.counter} (streak ${lastStreak} > max ${max})`, 'warning');
                    }
                    // If lastStreak < min, no change
                });
                
                this.updatePairsDisplay();
                this.updateThresholdStatus();
                this.initializeStakeSettings(); // Update stake display
            }

            // FIXED: Only trade at min or max, and only if counter >= threshold
            checkTradingOpportunities() {
                // Check daily loss limit
                const currentLoss = this.sessionStartBalance - this.balance;
                if (currentLoss >= this.maxDailyLoss) {
                    this.log(`Daily loss limit reached (${this.maxDailyLoss}). Stopping auto trading.`, 'error');
                    this.autoTrading = false;
                    this.updateAutoTradingButton();
                    return;
                }
                
                this.pairs.forEach((pair, index) => {
                    const [min, max] = pair.streakRange;
                    
                    if (pair.counter >= this.lossThreshold) {
                        if (this.currentStreak === min || this.currentStreak === max) {
                            const tradeIndex = this.currentStreak === min ? 0 : 1;
                            const tradeKey = `${index}-${this.currentStreak}`;
                            
                            if (!this.tradedOnCurrentStreak.has(tradeKey)) {
                                this.executeTrade(index, tradeIndex);
                                this.tradedOnCurrentStreak.add(tradeKey);
                            }
                        }
                    }
                });
            }

            executeTrade(pairIndex, tradeIndex) {
                if (!this.connected) {
                    this.log('Not connected to Deriv API', 'error');
                    return;
                }

                // Trade throttling check
                const now = Date.now();
                if (now - this.lastTradeTime < this.tradeThrottleMs) {
                    this.log(`Trade throttled - ${Math.ceil((this.tradeThrottleMs - (now - this.lastTradeTime)) / 1000)}s remaining`, 'warning');
                    return;
                }

                // Max concurrent trades check
                if (this.activeTrades >= this.maxConcurrentTrades) {
                    this.log(`Maximum concurrent trades reached (${this.maxConcurrentTrades})`, 'warning');
                    return;
                }

                // Pending trade check
                if (this.pendingTrade) {
                    this.log('Another trade is already being processed', 'warning');
                    return;
                }

                const stakes = this.getStakesForPair(pairIndex);
                const stake = stakes[tradeIndex];
                
                if (typeof stake !== 'number' || isNaN(stake) || stake <= 0) {
                    this.log('Invalid stake value. Trade not executed.', 'error');
                    return;
                }
                
                if (this.balance < stake) {
                    this.log(`Insufficient balance for ${stake} trade. Current balance: ${this.balance.toFixed(2)}`, 'error');
                    return;
                }
                
                const roundedStake = parseFloat(stake.toFixed(2));
                const pair = this.pairs[pairIndex];

                const proposalParams = {
                    proposal: 1,
                    amount: roundedStake,
                    basis: 'stake',
                    contract_type: 'DIGITUNDER',
                    symbol: 'R_50',
                    duration: 10,
                    duration_unit: 't',
                    barrier: '4',
                    currency: 'USD',
                    req_id: this.requestId++
                };

                this.pendingTrade = {
                    pairIndex,
                    tradeIndex,
                    roundedStake,
                    pair,
                    proposalReqId: proposalParams.req_id,
                    timestamp: now
                };

                this.lastTradeTime = now;

                this.log(`🎯 Requesting proposal for Pair ${pairIndex + 1} (${pair.name}) - ` +
                        `${tradeIndex === 0 ? '1st' : '2nd'} Trade - Stake: ${roundedStake} - Counter: ${pair.counter} - Level: ${pair.currentStakeLevel}`, 'info');
                
                this.send(proposalParams);

                setTimeout(() => {
                    if (this.pendingTrade && this.pendingTrade.timestamp === now) {
                        this.log('Trade proposal timed out, clearing pending trade', 'warning');
                        this.pendingTrade = null;
                    }
                }, 20000);
            }

            handleTradeResult(result) {
                if (result.error) {
                    this.log(`Trade failed: ${result.error.code || 'Unknown error'} - ${result.error.message || ''}`, 'error');
                    this.pendingTrade = null;
                    return;
                }
                
                if (result.buy) {
                    this.activeTrades++;
                    
                    // FIXED: Store trade info for proper win/loss handling
                    if (this.pendingTrade) {
                        this.activePairTrades.set(result.buy.contract_id, {
                            pairIndex: this.pendingTrade.pairIndex,
                            tradeIndex: this.pendingTrade.tradeIndex,
                            stake: this.pendingTrade.roundedStake,
                            timestamp: this.pendingTrade.timestamp
                        });
                    }
                    
                    this.log(`✅ Trade executed successfully! Contract ID: ${result.buy.contract_id} - Stake: ${result.buy.buy_price}`, 'success');
                    this.updateDisplay();
                    this.pendingTrade = null;

                    const subscribeMessage = {
                        proposal_open_contract: 1,
                        contract_id: result.buy.contract_id,
                        subscribe: 1,
                        req_id: this.requestId++
                    };
                    this.send(subscribeMessage);
                    this.contractSubscriptions.add(result.buy.contract_id);
                }
            }

            // FIXED: Proper win/loss detection and stake level management
            handleContractUpdate(contract) {
                if (contract.is_sold) {
                    this.activeTrades = Math.max(0, this.activeTrades - 1);
                    const pnl = contract.sell_price - contract.buy_price;
                    this.totalPnL += pnl;
                    
                    // Get trade info
                    const tradeInfo = this.activePairTrades.get(contract.contract_id);
                    
                    if (pnl > 0) {
                        // WIN
                        this.log(`🎉 Trade WON: +${pnl.toFixed(2)} (Contract: ${contract.contract_id})`, 'success');
                        
                        // FIXED: Reset the winning pair's counter AND stake level
                        if (tradeInfo && typeof tradeInfo.pairIndex === 'number') {
                            const pairIdx = tradeInfo.pairIndex;
                            if (this.pairs[pairIdx]) {
                                this.pairs[pairIdx].counter = 0;
                                this.pairs[pairIdx].currentStakeLevel = 1; // Reset to base stake level
                                this.log(`💚 Pair ${pairIdx + 1} (${this.pairs[pairIdx].name}) counter RESET to 0, stakes RESET to base level`, 'success');
                                this.updatePairsDisplay();
                                this.updateThresholdStatus();
                                this.initializeStakeSettings();
                            }
                        }
                    } else {
                        // LOSS
                        this.log(`❌ Trade LOST: -${Math.abs(pnl).toFixed(2)} (Contract: ${contract.contract_id})`, 'error');
                        
                        // FIXED: Increment stake level for the losing pair
                        if (tradeInfo && typeof tradeInfo.pairIndex === 'number') {
                            const pairIdx = tradeInfo.pairIndex;
                            if (this.pairs[pairIdx]) {
                                this.pairs[pairIdx].currentStakeLevel++;
                                this.log(`📈 Pair ${pairIdx + 1} stake level increased to ${this.pairs[pairIdx].currentStakeLevel}`, 'warning');
                                this.updatePairsDisplay();
                                this.initializeStakeSettings();
                            }
                        }
                    }
                    
                    // Clean up
                    this.activePairTrades.delete(contract.contract_id);
                    this.contractSubscriptions.delete(contract.contract_id);
                    this.updateDisplay();
                }
            }

            emergencyStop() {
                this.autoTrading = false;
                this.updateAutoTradingButton();
                this.pendingTrade = null;
                this.tradedOnCurrentStreak.clear();
                this.activePairTrades.clear();
                this.log('🛑 EMERGENCY STOP ACTIVATED - All trading halted immediately!', 'error');
            }

            resetAllPairs() {
                this.pairs.forEach(pair => {
                    pair.counter = 0;
                    pair.maxReached = 0;
                    pair.currentStakeLevel = 1; // FIXED: Reset stake levels
                });
                this.currentStreak = 0;
                this.maxStreak = 0;
                this.tradedOnCurrentStreak.clear();
                this.pendingTrade = null;
                this.activePairTrades.clear();
                this.totalPnL = 0;
                this.sessionStartBalance = this.balance;
                this.updateDisplay();
                this.updatePairsDisplay();
                this.updateThresholdStatus();
                this.initializeStakeSettings();
                this.log('All pairs, streaks, stake levels, and P&L reset', 'info');
            }

            toggleAutoTrading() {
                if (!this.connected) {
                    this.log('Cannot start trading - not connected to API', 'error');
                    return;
                }

                this.autoTrading = !this.autoTrading;
                this.updateAutoTradingButton();
                
                if (this.autoTrading) {
                    if (this.sessionStartBalance === 0) {
                        this.sessionStartBalance = this.balance;
                    }
                    this.log(`🚀 Auto trading STARTED - Session balance: ${this.sessionStartBalance.toFixed(2)} - Loss Threshold: ${this.lossThreshold}`, 'success');
                } else {
                    this.log('⏸️ Auto trading STOPPED', 'warning');
                }
            }

            updateAutoTradingButton() {
                const btn = document.getElementById('autoTradingBtn');
                if (this.autoTrading) {
                    btn.textContent = 'Stop Auto Trading';
                    btn.className = 'btn btn-danger';
                } else {
                    btn.textContent = 'Start Auto Trading';
                    btn.className = 'btn btn-primary';
                }
            }

            updateConnectionStatus(status) {
                const statusEl = document.getElementById('connectionStatus');
                statusEl.className = `connection-status ${status}`;
                statusEl.textContent = status.charAt(0).toUpperCase() + status.slice(1);
            }

            updateDisplay() {
                document.getElementById('currentStreak').textContent = this.currentStreak;
                document.getElementById('maxStreak').textContent = this.maxStreak;
                document.getElementById('balance').textContent = `${this.balance.toFixed(2)}`;
                
                // Color-code P&L
                const pnlElement = document.getElementById('totalPnL');
                pnlElement.textContent = `${this.totalPnL.toFixed(2)}`;
                if (this.totalPnL > 0) {
                    pnlElement.style.color = '#4CAF50';
                } else if (this.totalPnL < 0) {
                    pnlElement.style.color = '#f44336';
                } else {
                    pnlElement.style.color = '#fff';
                }

                // Update risk indicator
                const riskIndicator = document.getElementById('riskIndicator');
                riskIndicator.className = `risk-indicator risk-${this.riskLevel}`;
                riskIndicator.textContent = `Current Risk: ${this.riskLevel.toUpperCase()} - Always Start at Base Stakes`;
            }

            // FIXED: Updated pairs display with stake level tracking
            updatePairsDisplay() {
                this.pairs.forEach((pair, index) => {
                    const pairCard = document.getElementById(`pair-${index}`);
                    const counterEl = document.getElementById(`pair-${index}-counter`);
                    const maxEl = document.getElementById(`pair-${index}-max`);
                    const levelEl = document.getElementById(`pair-${index}-level`);
                    const stakesEl = document.getElementById(`pair-${index}-stakes`);
                    
                    if (counterEl) counterEl.textContent = pair.counter;
                    if (maxEl) maxEl.textContent = pair.maxReached;
                    if (levelEl) levelEl.textContent = pair.currentStakeLevel;
                    
                    // Show current stakes for this pair
                    if (stakesEl) {
                        const stakes = this.getStakesForPair(index);
                        if (pair.counter < this.lossThreshold) {
                            stakesEl.textContent = 'Not ready';
                            stakesEl.style.color = '#ccc';
                        } else {
                            stakesEl.textContent = `${stakes[0]} | ${stakes[1]}`;
                            stakesEl.style.color = '#4ecdc4';
                        }
                    }
                    
                    const [min, max] = pair.streakRange;
                    if (pairCard) {
                        pairCard.classList.remove('active', 'ready-to-trade');
                        
                        // Check if pair is ready to trade and currently active
                        if (pair.counter >= this.lossThreshold && 
                            (this.currentStreak === min || this.currentStreak === max)) {
                            pairCard.classList.add('active');
                        } else if (pair.counter >= this.lossThreshold) {
                            pairCard.classList.add('ready-to-trade');
                        }
                    }
                });
            }
            
            log(message, type = 'info') {
                const logDiv = document.getElementById('tradingLog');
                const entry = document.createElement('div');
                entry.className = `log-entry log-${type}`;
                entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                logDiv.appendChild(entry);
                logDiv.scrollTop = logDiv.scrollHeight;
                
                // Keep only last 100 log entries
                while (logDiv.children.length > 100) {
                    logDiv.removeChild(logDiv.firstChild);
                }
            }

            updateLossThreshold(value) {
                const numValue = parseInt(value);
                if (!isNaN(numValue) && numValue >= 0 && numValue <= 10) {
                    this.lossThreshold = numValue;
                    this.updateThresholdStatus();
                    this.updatePairsDisplay();
                    this.log(`Loss threshold updated to ${numValue}`, 'info');
                } else {
                    this.log('Invalid threshold value. Must be between 0 and 10', 'error');
                    document.getElementById('lossThresholdValue').value = this.lossThreshold;
                }
            }

            updateRiskLevel(level) {
                this.riskLevel = level;
                // FIXED: Reset all stake levels when changing risk level
                this.pairs.forEach(pair => {
                    pair.currentStakeLevel = 1;
                });
                this.initializeStakeSettings();
                this.updatePairsDisplay();
                this.updateDisplay();
                this.log(`Risk level changed to ${level.toUpperCase()} - All stake levels reset to 1`, 'info');
            }
        }

        // Global bot instance
        const bot = new StreakMasterProFixed();

        // Global functions
        function connectWebSocket() {
            const token = document.getElementById('apiToken').value.trim();
            if (!token) {
                alert('Please enter your API token');
                return;
            }
            bot.connect(token);
        }
        window.connectWebSocket = connectWebSocket;

        function disconnectWebSocket() {
            bot.disconnect();
        }
        window.disconnectWebSocket = disconnectWebSocket;

        function toggleAutoTrading() {
            bot.toggleAutoTrading();
        }
        window.toggleAutoTrading = toggleAutoTrading;

        function emergencyStop() {
            if (confirm('Are you sure you want to activate emergency stop? This will halt all trading immediately.')) {
                bot.emergencyStop();
            }
        }
        window.emergencyStop = emergencyStop;

        function resetAllPairs() {
            if (confirm('Are you sure you want to reset all pairs and P&L? This action cannot be undone.')) {
                bot.resetAllPairs();
            }
        }
        window.resetAllPairs = resetAllPairs;

        function updateLossThreshold(value) {
            bot.updateLossThreshold(value);
        }
        window.updateLossThreshold = updateLossThreshold;

        function setRiskLevel(level) {
            bot.updateRiskLevel(level);
            document.querySelectorAll('.risk-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
        }
        window.setRiskLevel = setRiskLevel;

        // Initialize display
        bot.updateDisplay();

        // Add keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if ((event.ctrlKey || event.metaKey) && event.code === 'Space') {
                event.preventDefault();
                emergencyStop();
            }
            
            if ((event.ctrlKey || event.metaKey) && event.code === 'KeyT') {
                event.preventDefault();
                toggleAutoTrading();
            }
        });

        bot.log('🎯 StreakMaster Pro STAKES FIXED VERSION Ready!', 'success');
        bot.log('✅ FIXED: Stakes always start at base level (0.35, 0.50) regardless of counter', 'success');
        bot.log('✅ FIXED: Counter determines IF pair can trade, not WHICH stake level', 'success');
        bot.log('✅ FIXED: Stake levels progress only on losses, reset on wins', 'success');
        bot.log('✅ FIXED: Win = Reset counter to 0 AND stake level to 1', 'success');
        bot.log('💡 Example: Counter 8 + Threshold 4 = Trades at stakes (0.35, 0.50) NOT (862, 1466)', 'info');
        bot.log('Keyboard shortcuts: Ctrl+Space = Emergency Stop, Ctrl+T = Toggle Trading', 'info');
    </script>
</body>
</html>